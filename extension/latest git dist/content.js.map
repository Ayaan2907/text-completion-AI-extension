{"version":3,"file":"content.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClBA;AACA;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./src/types.ts","webpack:///./src/utils/constants.ts","webpack:///./src/utils/ui.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/content.ts"],"sourcesContent":["/// <reference types=\"chrome\"/>\nexport const LLM_MODELS = [\n    {\n        value: 'claude',\n        label: 'Puter-lclaude',\n        api_url: 'https://api.puter.com/drivers/call',\n        requires_api_key: false,\n        uses_puter_token: true\n    },\n];\nexport const defaultSettings = {\n    apiKey: '',\n    enabled: true,\n    debug: false,\n    userContext: 'I am a professional who writes clear and concise text.',\n    wordMode: false,\n    model: LLM_MODELS[0],\n    puterAuthToken: '',\n};\n","export const DEBOUNCE_DELAY = 800; // ms\nexport const LOADER_COLOR = '#666666'; // Same as suggestion color for consistency \n","// Helper to measure text width\nfunction measureText(text, element) {\n    const span = document.createElement('span');\n    span.style.cssText = `\n    position: absolute;\n    visibility: hidden;\n    font: ${getComputedStyle(element).font};\n    letter-spacing: ${getComputedStyle(element).letterSpacing};\n    white-space: pre;\n  `;\n    span.textContent = text;\n    document.body.appendChild(span);\n    const width = span.offsetWidth;\n    document.body.removeChild(span);\n    return width;\n}\nexport function createSuggestionElement(text) {\n    const element = document.createElement('span');\n    element.textContent = text;\n    element.style.cssText = `\n    position: fixed;\n    color: #8c8c8c;\n    pointer-events: none;\n    white-space: pre;\n    font: inherit;\n    opacity: 0.8;\n    z-index: 10000;\n  `;\n    element.dataset.type = 'suggestion';\n    return element;\n}\n// Add loader styles to head once\nlet loaderStylesAdded = false;\nexport function ensureLoaderStyles() {\n    if (loaderStylesAdded)\n        return;\n    const style = document.createElement('style');\n    style.textContent = `\n    @keyframes aiLoaderSpin {\n      to { transform: rotate(360deg); }\n    }\n    .ai-loader {\n      position: fixed;\n      width: 12px;\n      height: 12px;\n      border: 1.5px solid #8c8c8c;\n      border-radius: 50%;\n      border-top-color: transparent;\n      animation: aiLoaderSpin 0.6s linear infinite;\n      opacity: 0.6;\n      margin-left: 2px;\n      z-index: 10000;\n    }\n  `;\n    document.head.appendChild(style);\n    loaderStylesAdded = true;\n}\nexport function createLoaderElement() {\n    ensureLoaderStyles();\n    const loader = document.createElement('div');\n    return loader;\n}\nfunction getCaretCoordinates(element, position) {\n    const rect = element.getBoundingClientRect();\n    const isInput = element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement;\n    if (isInput) {\n        const input = element;\n        const textBeforeCursor = input.value.substring(0, position);\n        const span = document.createElement('span');\n        span.style.cssText = `\n      position: absolute;\n      visibility: hidden;\n      font: ${getComputedStyle(input).font};\n      letter-spacing: ${getComputedStyle(input).letterSpacing};\n      white-space: pre;\n    `;\n        span.textContent = textBeforeCursor;\n        document.body.appendChild(span);\n        const width = span.offsetWidth;\n        document.body.removeChild(span);\n        return {\n            x: rect.left + width,\n            y: rect.top + (rect.height / 2) - 6\n        };\n    }\n    else {\n        const selection = window.getSelection();\n        const range = selection === null || selection === void 0 ? void 0 : selection.getRangeAt(0);\n        if (!range)\n            return { x: rect.left, y: rect.top };\n        const rangeRect = range.getBoundingClientRect();\n        return {\n            x: rangeRect.right,\n            y: rangeRect.top + (rangeRect.height / 2) - 6\n        };\n    }\n}\nexport function showLoader(target, cursorPos) {\n    ensureLoaderStyles();\n    const loader = document.createElement('div');\n    loader.className = 'ai-loader';\n    document.body.appendChild(loader);\n    const coords = getCaretCoordinates(target, cursorPos);\n    loader.style.left = `${coords.x + window.scrollX}px`;\n    loader.style.top = `${coords.y + window.scrollY}px`;\n    return loader;\n}\nexport function showPrediction(target, cursorPos, prediction) {\n    const text = target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement\n        ? target.value\n        : target.textContent || '';\n    const beforeText = text.substring(0, cursorPos);\n    const afterText = text.substring(cursorPos);\n    // Store original state\n    target.dataset.originalText = text;\n    target.dataset.cursorPos = cursorPos.toString();\n    target.dataset.prediction = prediction;\n    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n        // For input/textarea elements\n        const predictedText = beforeText + prediction + afterText;\n        target.value = predictedText;\n        target.style.color = '#0066cc';\n        target.setSelectionRange(cursorPos, cursorPos + prediction.length);\n    }\n    else {\n        // For contenteditable elements\n        target.textContent = beforeText + prediction + afterText;\n        target.style.color = '#0066cc';\n        const range = document.createRange();\n        range.setStart(target.firstChild || target, cursorPos);\n        range.setEnd(target.firstChild || target, cursorPos + prediction.length);\n        const selection = window.getSelection();\n        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();\n        selection === null || selection === void 0 ? void 0 : selection.addRange(range);\n    }\n}\nexport function removePrediction(target) {\n    const originalText = target.dataset.originalText;\n    if (!originalText)\n        return;\n    const cursorPos = parseInt(target.dataset.cursorPos || '0');\n    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n        target.value = originalText;\n        target.style.color = '';\n        target.setSelectionRange(cursorPos, cursorPos);\n    }\n    else {\n        target.textContent = originalText;\n        target.style.color = '';\n        const range = document.createRange();\n        range.setStart(target.firstChild || target, cursorPos);\n        range.collapse(true);\n        const selection = window.getSelection();\n        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();\n        selection === null || selection === void 0 ? void 0 : selection.addRange(range);\n    }\n    delete target.dataset.originalText;\n    delete target.dataset.cursorPos;\n    delete target.dataset.prediction;\n}\nexport function acceptPrediction(target) {\n    const originalText = target.dataset.originalText;\n    const prediction = target.dataset.prediction;\n    if (!originalText || !prediction)\n        return;\n    const cursorPos = parseInt(target.dataset.cursorPos || '0');\n    const newText = originalText.substring(0, cursorPos) + prediction + originalText.substring(cursorPos);\n    if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {\n        target.value = newText;\n        target.style.color = '';\n        target.setSelectionRange(cursorPos + prediction.length, cursorPos + prediction.length);\n    }\n    else {\n        target.textContent = newText;\n        target.style.color = '';\n        const range = document.createRange();\n        range.setStart(target.firstChild || target, cursorPos + prediction.length);\n        range.collapse(true);\n        const selection = window.getSelection();\n        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();\n        selection === null || selection === void 0 ? void 0 : selection.addRange(range);\n    }\n    delete target.dataset.originalText;\n    delete target.dataset.cursorPos;\n    delete target.dataset.prediction;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference types=\"chrome\"/>\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defaultSettings } from './types';\nimport { DEBOUNCE_DELAY } from './utils/constants';\nimport { showLoader, showPrediction, removePrediction, acceptPrediction, ensureLoaderStyles } from './utils/ui';\n// Ensure we're in a Chrome extension context\nif (typeof chrome === 'undefined' || !chrome.runtime || !chrome.storage) {\n    console.error('Chrome extension APIs not available');\n    throw new Error('Chrome extension APIs not available');\n}\nlet settings = defaultSettings;\nlet debounceTimer = null;\nlet currentLoader = null;\nlet lastElement = null;\nlet lastInputContext = '';\n// Initialize loader styles\nensureLoaderStyles();\n// Initialize settings and notify background with page context\nfunction getPageMetadata() {\n    var _a, _b;\n    const metadata = [\n        document.title,\n        (_a = document.querySelector('meta[name=\"description\"]')) === null || _a === void 0 ? void 0 : _a.getAttribute('content'),\n        // Current section context (h1 or main heading)\n        (_b = document.querySelector('main h1, article h1')) === null || _b === void 0 ? void 0 : _b.textContent,\n        // URL path for context\n        new URL(window.location.href).pathname.split('/').filter(Boolean).join(' ')\n    ]\n        .filter(Boolean)\n        .map(text => text === null || text === void 0 ? void 0 : text.trim())\n        .filter((text) => typeof text === 'string' && text.length > 0)\n        .join(' | ')\n        .slice(0, 500);\n    return metadata;\n}\n// Function to extract Puter auth token from localStorage\nfunction getPuterAuthToken() {\n    try {\n        return localStorage.getItem('puter.auth.token');\n    }\n    catch (error) {\n        console.error('Error accessing localStorage for Puter token:', error);\n        return null;\n    }\n}\n// Initialize settings and notify background\nchrome.storage.sync.get(['settings'], (result) => {\n    settings = result.settings || defaultSettings;\n    // Check for Puter token and update settings if found\n    const puterToken = getPuterAuthToken();\n    if (puterToken && settings.puterAuthToken !== puterToken) {\n        settings.puterAuthToken = puterToken;\n        chrome.storage.sync.set({ settings });\n    }\n    // Send page context with ready message\n    chrome.runtime.sendMessage({\n        type: 'PAGE_READY',\n        pageContext: getPageMetadata()\n    });\n});\n// Check periodically for Puter token changes\nsetInterval(() => {\n    const token = getPuterAuthToken();\n    if (token && settings.puterAuthToken !== token) {\n        settings.puterAuthToken = token;\n        chrome.storage.sync.set({ settings });\n    }\n}, 60000); // Check every minute\n// Update settings when changed\nchrome.storage.onChanged.addListener((changes) => {\n    if (changes.settings) {\n        settings = changes.settings.newValue;\n    }\n});\nfunction isEditableElement(element) {\n    return element instanceof HTMLInputElement ||\n        element instanceof HTMLTextAreaElement ||\n        element.isContentEditable ||\n        element.getAttribute('contenteditable') === 'true' ||\n        element.getAttribute('role') === 'textbox' ||\n        element.classList.contains('notranslate') || // Gmail support\n        element.closest('[contenteditable=\"true\"]') !== null;\n}\nfunction getElementText(element) {\n    return element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement\n        ? element.value\n        : element.textContent || '';\n}\nfunction getCursorPosition(element) {\n    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n        return element.selectionStart || 0;\n    }\n    const selection = window.getSelection();\n    return (selection === null || selection === void 0 ? void 0 : selection.anchorOffset) || 0;\n}\nfunction getInputContext(element) {\n    var _a, _b;\n    // For input/textarea, check label and placeholder\n    if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n        // Check for associated label\n        const id = element.id;\n        const label = id ? (_a = document.querySelector(`label[for=\"${id}\"]`)) === null || _a === void 0 ? void 0 : _a.textContent : '';\n        if (label)\n            return label;\n        // Check placeholder\n        if (element.placeholder)\n            return element.placeholder;\n        // Check aria-label\n        if (element.getAttribute('aria-label'))\n            return element.getAttribute('aria-label') || '';\n    }\n    // For contenteditable, check parent's label-like elements\n    const parent = element.closest('[role=\"textbox\"]') || element.parentElement;\n    if (parent) {\n        const nearestLabel = ((_b = parent.querySelector('label')) === null || _b === void 0 ? void 0 : _b.textContent) ||\n            parent.getAttribute('aria-label') ||\n            (parent instanceof HTMLElement ? parent.title : '') ||\n            '';\n        if (nearestLabel)\n            return nearestLabel;\n    }\n    return '';\n}\nfunction handleInput(event) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const target = event.target;\n        if (!target || !isEditableElement(target) || !settings.enabled)\n            return;\n        // Remove prediction if the active input element is changed\n        if (target !== lastElement) {\n            if (lastElement) {\n                removePrediction(lastElement);\n            }\n            lastElement = target;\n        }\n        removePrediction(target);\n        if (currentLoader) {\n            currentLoader.remove();\n            currentLoader = null;\n        }\n        if (debounceTimer)\n            clearTimeout(debounceTimer);\n        const cursorPos = getCursorPosition(target);\n        const text = getElementText(target);\n        if (!text)\n            return;\n        if (settings.wordMode) {\n            const lastChar = text[cursorPos - 1];\n            if (lastChar !== ' ')\n                return;\n        }\n        debounceTimer = window.setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            // Only get input context if element changed\n            if (target !== lastElement) {\n                lastElement = target;\n                lastInputContext = getInputContext(target);\n            }\n            currentLoader = showLoader(target, cursorPos);\n            try {\n                // Ensure chrome.runtime is available\n                if (!chrome.runtime) {\n                    throw new Error('Chrome runtime not available');\n                }\n                const response = yield chrome.runtime.sendMessage({\n                    type: 'GET_PREDICTION',\n                    text,\n                    cursorPos,\n                    inputContext: lastInputContext // Send cached context\n                });\n                if (response === null || response === void 0 ? void 0 : response.prediction) {\n                    showPrediction(target, cursorPos, response.prediction);\n                }\n            }\n            catch (error) {\n                console.error('Error getting prediction:', error);\n                if (error instanceof Error && error.message.includes('Extension context invalidated')) {\n                    // Extension was reloaded/updated\n                    window.location.reload();\n                }\n            }\n            finally {\n                if (currentLoader) {\n                    currentLoader.remove();\n                    currentLoader = null;\n                }\n            }\n        }), DEBOUNCE_DELAY);\n    });\n}\nfunction handleKeydown(event) {\n    const target = event.target;\n    if (!target || !isEditableElement(target))\n        return;\n    if (event.key === 'Tab' && target.dataset.prediction) {\n        event.preventDefault();\n        event.stopPropagation();\n        acceptPrediction(target);\n    }\n    else if (event.key !== 'Tab') {\n        removePrediction(target);\n    }\n}\n// Add listeners to document and iframes\nfunction addListeners(doc) {\n    doc.addEventListener('input', handleInput);\n    doc.addEventListener('keydown', handleKeydown, true);\n}\n// Handle iframes\nfunction setupIframe(iframe) {\n    var _a;\n    try {\n        const doc = iframe.contentDocument || ((_a = iframe.contentWindow) === null || _a === void 0 ? void 0 : _a.document);\n        if (doc)\n            addListeners(doc);\n    }\n    catch (e) {\n        console.error('Error setting up iframe:', e);\n    }\n}\n// Initial setup\naddListeners(document);\ndocument.querySelectorAll('iframe').forEach(setupIframe);\n// Watch for new iframes\nconst observer = new MutationObserver(mutations => {\n    mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n            if (node instanceof HTMLIFrameElement) {\n                setupIframe(node);\n            }\n        });\n    });\n});\nobserver.observe(document.body, {\n    childList: true,\n    subtree: true\n});\n// Cleanup\nwindow.addEventListener('unload', () => {\n    observer.disconnect();\n    document.removeEventListener('input', handleInput);\n    document.removeEventListener('keydown', handleKeydown);\n    if (currentLoader) {\n        currentLoader.remove();\n    }\n});\n"],"names":[],"sourceRoot":""}