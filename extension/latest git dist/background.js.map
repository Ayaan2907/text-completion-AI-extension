{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./src/services/ai.ts","webpack:///./src/types.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/background.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport class AIService {\n    constructor(settings) {\n        this.pageContext = '';\n        this.settings = settings;\n        // this.pageContext = pageContext;\n    }\n    updateSettings(newSettings) {\n        this.settings = newSettings;\n    }\n    updatePageContext(newContext) {\n        this.pageContext = newContext;\n    }\n    getPrediction(text, cursorPos, inputContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a, _b, _c;\n            if (!this.settings.apiKey || !this.settings.enabled)\n                return '';\n            // Get text around cursor (up to 100 chars each side for faster context)\n            const beforeText = text.substring(Math.max(0, cursorPos - 100), cursorPos);\n            const afterText = text.substring(cursorPos, Math.min(text.length, cursorPos + 100));\n            if (this.settings.debug) {\n                console.log('üìÑ Page Context:', this.pageContext);\n                console.log('üë§ User Context:', this.settings.userContext);\n                console.log('üè∑Ô∏è Input Context:', inputContext);\n                console.log('‚úçÔ∏è Input:', beforeText + '|' + afterText);\n            }\n            try {\n                const response = yield fetch(this.settings.model.api_url, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': `Bearer ${this.settings.puterAuthToken}`\n                        // 'x-api-key': this.settings.apiKey,\n                        // 'anthropic-version': '2023-06-01',\n                        // 'anthropic-dangerous-direct-browser-access': 'true'\n                    },\n                    body: JSON.stringify({\n                        driver: this.settings.model,\n                        model: this.settings.model.value,\n                        // max_tokens: 230,\n                        args: {\n                            messages: [\n                                {\n                                    role: 'user',\n                                    content: `You are a text completion AI. Based on these contexts:\n              - About the user: ${this.settings.userContext}\n              - Current page: ${this.pageContext}\n              - Input field: ${inputContext || 'None'}\n              \n              The user has typed: \"${beforeText}\"\n              \n              Continue this text naturally. IMPORTANT:\n              - ONLY provide the continuation text that comes AFTER the user's input\n              - DO NOT repeat any part of the input text\n              - DO NOT add quotes or explanations\n              - Keep the style and context consistent\n              - Take care of word end, spaces, if the word ended start with a space`\n                                }\n                            ]\n                        }\n                    })\n                });\n                if (!response.ok) {\n                    const errorData = yield response.json().catch(() => ({}));\n                    if (this.settings.debug) {\n                        console.error('API Error Response:', errorData);\n                    }\n                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);\n                }\n                const data = yield response.json();\n                // const prediction = data.choices?.[0]?.message?.content?.trim() || '';\n                const prediction = ((_c = (_b = (_a = data.content) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.text) === null || _c === void 0 ? void 0 : _c.trim()) || '';\n                if (this.settings.debug && prediction) {\n                    console.log('üí° Completion:', prediction);\n                }\n                return prediction;\n            }\n            catch (error) {\n                if (this.settings.debug) {\n                    console.error('‚ùå API Error:', error);\n                }\n                return '';\n            }\n        });\n    }\n}\n","/// <reference types=\"chrome\"/>\nexport const LLM_MODELS = [\n    {\n        value: 'claude',\n        label: 'Puter-lclaude',\n        api_url: 'https://api.puter.com/drivers/call',\n        requires_api_key: false,\n        uses_puter_token: true\n    },\n];\nexport const defaultSettings = {\n    apiKey: '',\n    enabled: true,\n    debug: false,\n    userContext: 'I am a professional who writes clear and concise text.',\n    wordMode: false,\n    model: LLM_MODELS[0],\n    puterAuthToken: '',\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { defaultSettings } from './types';\nimport { AIService } from './services/ai';\n// Ensure service worker stays active\nchrome.runtime.onInstalled.addListener(() => {\n    console.log('Extension installed');\n});\nlet settings = defaultSettings;\nconst aiService = new AIService(settings);\n// Initialize settings\nchrome.storage.sync.get(['settings'], (result) => {\n    settings = result.settings || defaultSettings;\n    aiService.updateSettings(settings);\n});\n// Listen for settings changes\nchrome.storage.onChanged.addListener((changes) => {\n    if (changes.settings) {\n        settings = changes.settings.newValue;\n        aiService.updateSettings(settings);\n    }\n});\n// Handle messages from content script\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    var _a;\n    if (request.type === 'PAGE_READY') {\n        // Update AI service with page context\n        aiService.updatePageContext(request.pageContext || '');\n        return;\n    }\n    if (request.type === 'GET_PREDICTION') {\n        const { text, cursorPos, inputContext } = request;\n        if (!settings.enabled) {\n            sendResponse({ prediction: '' });\n            return true;\n        }\n        // For Puter model, we use the puterAuthToken instead of apiKey TOEDIT:\n        const isPuterModel = ((_a = settings.model) === null || _a === void 0 ? void 0 : _a.value) === 'claude' ||\n            (typeof settings.model === 'object' && settings.model.label === 'Puter-lclaude');\n        if (!isPuterModel && !settings.apiKey) {\n            sendResponse({ prediction: '' });\n            return true;\n        }\n        if (isPuterModel && !settings.puterAuthToken) {\n            sendResponse({ prediction: '' });\n            return true;\n        }\n        // Handle API call in background\n        aiService.getPrediction(text, cursorPos, inputContext)\n            .then(prediction => {\n            sendResponse({ prediction });\n        })\n            .catch(error => {\n            console.error('Error:', error);\n            sendResponse({ prediction: '' });\n        });\n        return true; // Keeping the message channel open for async response\n    }\n});\n"],"names":[],"sourceRoot":""}